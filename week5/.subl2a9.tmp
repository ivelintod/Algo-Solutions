'''    def adjacency_matrix(self):
        matrix = [[0 for x in range(2 * len(self.seq))] for y in range(2 * len(self.seq))]
        extended_seq = []
        for i in self.seq:
            extended_seq.append((i, i[4:] + i[3] + i[:3]))
            #extended_seq.append(i[4:] + i[3] + i[:3])
        #f = lambda x : x, x[4:] + x[3] + x[:3]
        #extended_seq = map(f, self.seq)
        for i in extended_seq:
            self.graph[i] = []
        for k in extended_seq:
            for j in extended_seq:
                if j == k:
                    pass
                else:
                    if k[0][:3] == j[0][4:] or k[0][:3] == j[1][4:]:
                        self.graph[j].append((j, 0))
                    elif k[1][:3] == j[0][4] or k[1][:3] == j[1][4:]:
                        self.graph[j].append()


    def add_connections(self):
        for i in range(len(self.seq)):
            for j in range(len(self.seq)):
                if i == j:
                    pass
                else:
                    if self.seq[i][:3] == self.seq[j][4:] or self.seq[i][4:] == self.seq[j][:3]:
                        self.graph[self.seq[i]].append(self.seq[j])

    def check_connectivity(self, x, y):
        if x[:3] == y[:3]:
            return x[len(x) - 3:] + x[3:len(x) - 3] + y
        elif x[:3] == y[len(y) - 3:]:
            return y + x[3:]
        elif x[len(x) - 3:] == y[:3]:
            return x + y[3:]
        elif x[len(x) - 3:] == y[len(y) - 3:]:
            return x + y[3:len(y) - 3] + y[:3]

    def sth(self):
        start = self.seq[8]
        extended_seq = []
        for i in self.seq:
            extended_seq.append(i)
            extended_seq.append(i[4:] + i[3:len(i) - 3] + i[:3])
        visited = list()
        queue = list()
        queue.append(start)
        index = 0
        visited.append(start)
        visited.append(start[4:] + start[3] + start[:3])
        while index < len(queue):
            #equal = queue[index][4:] + queue[index][3] + queue[index][:3]
            #if len(queue[index]) == (len(self.seq) - 1) * (len(start) - 3) + len(start):
            if len(visited) == len(self.seq):
                return queue[index]
            for i in extended_seq:
                if i not in visited:
                    if self.check_connectivity(queue[index], i) != None:
                        queue.append(self.check_connectivity(queue[index], i))
                        visited.append(i)
                        visited.append(i[4:] + i[3] + i[:3])
                        break
            index += 1
            if index == len(queue):
                pass
        return "NO WAY, FUCKER!"

    def give_weight(self):
        weight = 0
        weight_graph = {}
        for i in self.seq:
            for j in self.seq:
                if i != j:
                    if i[:3] == j[:3] or i[:3] == j[len(i) - 3:] or i[len(i) - 3:] in j[:3] or i[len(i) - 3] == j[len(j) - 3]:
                        weight += 1
            weight_graph[i] = weight
            weight = 0
        return weight_graph'''

class DNA:

    def __init__(self, num, seq):
        self.num = num
        self.seq = seq
        self.graph = {}

    def make_graph(self):
        for nuc in self.seq:
            self.graph[nuc[:3]] = []
            self.graph[nuc[len(nuc) - 3:]] = []
        for nuc in self.seq:
            self.graph[nuc[:3]].append((nuc[len(nuc) - 3:], nuc[3:len(nuc) - 3]))
            self.graph[nuc[len(nuc) - 3:]].append((nuc[:3], nuc[3:len(nuc) - 3]))

    def uniform_span_tree(self):
        count = 0
        vertices = {x[:3] for x in self.seq}
        for x in self.seq:
            vertices.add(x[len(x) - 3:])
        vertices = list(vertices)
        odd_2_cycle = []
        for vertice in vertices:
            if len(self.graph[vertice]) % 2 != 0:
                count += 1
                odd_2_cycle.append(vertice)

        print(odd_2_cycle)

        #if count == 0 or count == 2:
        if count == 0:
            start = vertices[0]

        elif count == 2:
            start = odd_2_cycle[0]
            print(start)

        else:
            print("IMPOSSIBLE")
            return

        check_cycle = set()
        visited = []
        result = start
        target_len = len(self.seq[0]) + (self.num - 1) * (len(self.seq[0][3:len(self.seq[0]) - 3]) + 3)
        while len(result) != target_len - 4:
            check_cycle.add(start)
            for conn in self.graph[start]:
                if (start, conn[0]) not in visited and conn[0] == odd_2_cycle[1] and conn[0] not in check_cycle:
                    result += conn[1] + conn[0]
                    visited.append((start, conn[0]))
                    visited.append((conn[0], start))
                    check_cycle.add(conn[0])
                    start = conn[0]

                elif (start, conn[0]) not in visited: #and conn[0] != odd_2_cycle[1]:
                    result += conn[1] + conn[0]
                    visited.append((start, conn[0]))
                    visited.append((conn[0], start))
                    #visited.append((start, odd_2_cycle[1]))
                    start = conn[0]
                    break

            print(visited)
            print(start)
            print(result)
        for conn in self.graph[result[len(result) - 3:]]:
            if conn[0] == odd_2_cycle[1]:
                result += conn[1] + conn[0]
        print(result)


#TPFTASDGFFFJKEKLHUEFFFF
#HUEFASDGFFFJKEKLHUEWMLSALEL
#TPFTASDGFFFJKEKLHUEWMLSALELGFOPUHUE
#ASDGFFFJKEKLHUEUFOPGLELAMLSWHUEFASDTTPF
def main():
    d = DNA(9, ['FFFGASD', 'FFFJKEK', 'FFFFHUE', 'KEKLHUE', 'HUEWMLS', 'HUEUFOP', 'FOPGLEL', 'MLSALEL', 'ASDTTPF'])
    #d.construct_graph()
    #d.add_connections()
    #print d.graph
    #print d.sth()
    #print d.check_connectivity('MLSGFFFJASDFKEKLHUEWHUEUFOPGLEL', d.seq[7])
    #print d.give_weight()
    d.make_graph()
    print(d.graph)
    d.uniform_span_tree()
    start = 'FFFGASD'
    print(len(start) + 8 * (len(start[3:len(start) - 3]) + 3))


if __name__ == '__main__':
    main()



